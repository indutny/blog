<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Structure of FTS5 Index in SQLite</title>
		<meta name="description" content="Darkside of Software Engineering.">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Fedor Indutny&#39;s Blog">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="Fedor Indutny&#39;s Blog">
		<meta name="generator" content="Eleventy v2.0.0">
		
		<style>/* Only include the syntax highlighter CSS on blog posts */
/**
 * okaidia theme for JavaScript, CSS and HTML
 * Loosely based on Monokai textmate theme by http://www.monokai.nl/
 * @author ocodia
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #8292a2;
}

.token.punctuation {
	color: #f8f8f2;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function,
.token.class-name {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

/*
 * New diff- syntax
 */

pre[class*="language-diff-"] {
	--eleventy-code-padding: 1.25em;
	padding-left: var(--eleventy-code-padding);
	padding-right: var(--eleventy-code-padding);
}
.token.deleted {
	background-color: hsl(0, 51%, 37%);
	color: inherit;
}
.token.inserted {
	background-color: hsl(126, 31%, 39%);
	color: inherit;
}

/* Make the + and - characters unselectable for copy/paste */
.token.prefix.unchanged,
.token.prefix.inserted,
.token.prefix.deleted {
	-webkit-user-select: none;
	user-select: none;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	padding-top: 2px;
	padding-bottom: 2px;
}
.token.prefix.inserted,
.token.prefix.deleted {
	width: var(--eleventy-code-padding);
	background-color: rgba(0,0,0,.2);
}

/* Optional: full-width background color */
.token.inserted:not(.prefix),
.token.deleted:not(.prefix) {
	display: block;
	margin-left: calc(-1 * var(--eleventy-code-padding));
	margin-right: calc(-1 * var(--eleventy-code-padding));
	text-decoration: none; /* override del, ins, mark defaults */
	color: inherit; /* override del, ins, mark defaults */
}
* { box-sizing: border-box; }
/* Defaults */
:root {
	--font-family: -apple-system, system-ui, sans-serif;
	--font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
}

/* Theme colors */
:root {
	--color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333;

	--background-color: #fff;

	--text-color: var(--color-gray-90);
	--text-color-link: #082840;
	--text-color-link-active: #5f2b48;
	--text-color-link-visited: #17050F;

	--syntax-tab-size: 2;
}

@media (prefers-color-scheme: dark) {
	:root {
		--color-gray-20: #e0e0e0;
		--color-gray-50: #C0C0C0;
		--color-gray-90: #dad8d8;

		/* --text-color is assigned to --color-gray-_ above */
		--text-color-link: #1493fb;
		--text-color-link-active: #6969f7;
		--text-color-link-visited: #a6a6f8;

		--background-color: #15202b;
	}
}


/* Global stylesheet */
* {
	box-sizing: border-box;
}

html,
body {
	padding: 0;
	margin: 0 auto;
	font-family: var(--font-family);
	color: var(--text-color);
	background-color: var(--background-color);
}
html {
	overflow-y: scroll;
}
body {
	max-width: 40em;
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.5;
}

li {
	line-height: 1.5;
}

a[href] {
	color: var(--text-color-link);
}
a[href]:visited {
	color: var(--text-color-link-visited);
}
a[href]:hover,
a[href]:active {
	color: var(--text-color-link-active);
}

main {
	padding: 1rem;
}
main :first-child {
	margin-top: 0;
}

header {
	border-bottom: 1px dashed var(--color-gray-20);
}
header:after {
	content: "";
	display: table;
	clear: both;
}

.links-nextprev {
	list-style: none;
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}

table {
	margin: 1em 0;
}
table td,
table th {
	padding-right: 1em;
}

pre,
code {
	font-family: var(--font-family-monospace);
}
pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	-moz-tab-size: var(--syntax-tab-size);
	-o-tab-size: var(--syntax-tab-size);
	tab-size: var(--syntax-tab-size);
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
}
code {
	word-break: normal;
}

/* Header */
header {
	display: flex;
	gap: 1em .5em;
	flex-wrap: wrap;
	align-items: center;
	padding: 1em;
}
.home-link {
	font-size: 1em; /* 16px /16 */
	font-weight: 700;
	margin-right: 2em;
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */
.nav {
	display: flex;
	padding: 0;
	margin: 0;
	list-style: none;
  align-items: center;
}
.nav-item {
	display: inline-block;
	margin-right: 1em;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}
.nav-item svg.social {
  display: block;
  width: 18px;
  height: 18px;
}

/* Posts list */
.postlist {
	list-style: none;
	padding: 0;
	padding-left: 1.5rem;
}
.postlist-item {
	display: flex;
	flex-wrap: wrap;
	align-items: baseline;
	counter-increment: start-from -1;
	margin-bottom: 1em;
}
.postlist-item:before {
	display: inline-block;
	pointer-events: none;
	content: "" counter(start-from, decimal-leading-zero) ". ";
	line-height: 100%;
	text-align: right;
	margin-left: -1.5rem;
}
.postlist-date,
.postlist-item:before {
	font-size: 0.8125em; /* 13px /16 */
	color: var(--color-gray-90);
}
.postlist-date {
	word-spacing: -0.5px;
}
.postlist-link {
	font-size: 1.1875em; /* 19px /16 */
	font-weight: 700;
	flex-basis: calc(100% - 1.5rem);
	padding-left: .25em;
	padding-right: .5em;
	text-underline-position: from-font;
	text-underline-offset: 0;
	text-decoration-thickness: 1px;
}
.postlist-item-active .postlist-link {
	font-weight: bold;
}

/* Tags */
.post-tag {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	text-transform: capitalize;
	font-style: italic;
}
.postlist-item > .post-tag {
	align-self: center;
}

/* Tags list */
.post-metadata {
	display: inline-flex;
	flex-wrap: wrap;
	gap: .5em;
	list-style: none;
	padding: 0;
	margin: 0;
}
.post-metadata time {
	margin-right: 1em;
}

/* Direct Links / Markdown Headers */
.header-anchor {
	text-decoration: none;
	font-style: normal;
	font-size: 1em;
	margin-left: .1em;
}
a[href].header-anchor,
a[href].header-anchor:visited {
	color: transparent;
}
a[href].header-anchor:focus,
a[href].header-anchor:hover {
	text-decoration: underline;
}
a[href].header-anchor:focus,
:hover > a[href].header-anchor {
	color: #aaa;
}

h2 + .header-anchor {
	font-size: 1.5em;
}

footer {
  padding: 1.5em 0 0.5em 0;
  font-size: 0.75em;
  text-align: right;
}

img {
  max-width: 100%;
  height: auto;
}</style>
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header>
			<a href="/" class="home-link">Fedor Indutny&#39;s Blog</a>

      
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
					<li class="nav-item"><a href="/blog/">Archive</a></li>
					<li class="nav-item"><a href="/about/">About Me</a></li>
          <li class="nav-item">
            <a href="https://github.com/indutny" target="_blank" rel="noreferrer">
              <svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16 social" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
            </a>
          </li>
          <li class="nav-item">
            <a href="https://fosstodon.org/@indutny" target="_blank" rel="me">
              <svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon fa-w-14 social" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg>
            </a>
          </li>
				</ul>
			</nav>
		</header>

		<main id="skip">
			
<h1>Structure of FTS5 Index in SQLite</h1>

<ul class="post-metadata">
	<li><time datetime="2023-02-26">26 February 2023</time></li>
	<li><a href="/tags/sqlite/" class="post-tag">SQLite</a></li>
</ul>

<p>Recently <a href="https://signal.org/">Signal</a> has
<a href="https://github.com/signalapp/Signal-FTS5-Extension">open-sourced a SQLite extension</a>
that provides better support for non-latin languages (Chinese, Japanese, etc) in
the Full-Text Search (FTS) virtual table. I was one of the engineers
who worked on this extension and in the course of this endeavor I got to learn
about the structure of the SQLite's FTS implementation.
<a href="https://www.sqlite.org/fts5.html">The existing documentation</a> focuses mostly
on API and its use patterns, and even though it covers some of the internal
storage format, I found it a bit confusing. Thus this article was born. Not as
alternative documentation for FTS5, but as a complement for developers who want
to dive in past the officially documented bits.</p>
<h2 id="how-is-fts5-used" tabindex="-1">How is FTS5 used <a class="header-anchor" href="#how-is-fts5-used">#</a></h2>
<p>Before anything else, though, let's see what the FTS5 looks like to the API
consumer. As with many other features of SQLite we start by creating a table:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">CREATE</span> VIRTUAL <span class="token keyword">TABLE</span> search<br>    <span class="token keyword">USING</span> fts5<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>This virtual table supports insertion, modification, and deletion of textual
content:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> search<span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><br>    <span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token string">'halló heimur'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token string">'你好世界'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> search<br>    <span class="token keyword">WHERE</span> content <span class="token operator">IS</span> <span class="token string">'halló heimur'</span><span class="token punctuation">;</span></code></pre>
<p>As well as special full-text search queries that can find an entry that has a
word (term) starting with a certain prefix:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">SELECT</span> content <span class="token keyword">FROM</span> search<br>    <span class="token keyword">WHERE</span> content <span class="token keyword">MATCH</span> <span class="token string">'wo*'</span><span class="token punctuation">;</span><br><span class="token comment">-- Output: 'hello world'</span></code></pre>
<p>In addition to that you could match on multiple words (not necessarily adjacent)
and sort by the search rank. The details of this are
<a href="https://www.sqlite.org/fts5.html#fts5_phrases">covered by the official documentation</a>
so we won't be discussing them much more here.</p>
<h2 id="signal-s-fts5-extension" tabindex="-1">Signal's FTS5 extension <a class="header-anchor" href="#signal-s-fts5-extension">#</a></h2>
<p>In the example above you might have noticed that we inserted a phrase in
Simplified Chinese: <code>你好世界</code>. What happens if we search for the second word of
it (<code>世界</code>)?</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">SELECT</span> content <span class="token keyword">FROM</span> search<br>    <span class="token keyword">WHERE</span> content <span class="token keyword">MATCH</span> <span class="token string">'世界*'</span><span class="token punctuation">;</span><br><span class="token comment">-- Output: nothing</span></code></pre>
<p>No resulting rows! The reason for that is that the default tokenizer for FTS5
has segmented <code>你好世界</code> as a single word (term), instead of either splitting
it into two words (example in JavaScript):</p>
<pre class="language-js" tabindex="0"><code class="language-js"><span class="token keyword">const</span> segmenter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intl<span class="token punctuation">.</span>Segmenter</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">granularity</span><span class="token operator">:</span> <span class="token string">'word'</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> segments <span class="token operator">=</span> <span class="token punctuation">[</span><br>    <span class="token operator">...</span>segmenter<span class="token punctuation">.</span><span class="token function">segment</span><span class="token punctuation">(</span><span class="token string">'你好世界'</span><span class="token punctuation">)</span><br><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">s</span> <span class="token operator">=></span> s<span class="token punctuation">.</span>segment<span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>segments<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Output: [ '你好', '世界' ]</span></code></pre>
<p>or at the very least into separate CJK symbols:</p>
<pre class="language-js" tabindex="0"><code class="language-js"><span class="token punctuation">[</span> <span class="token string">'你'</span><span class="token punctuation">,</span> <span class="token string">'好'</span><span class="token punctuation">,</span> <span class="token string">'世'</span><span class="token punctuation">,</span> <span class="token string">'界'</span> <span class="token punctuation">]</span></code></pre>
<p>Since FTS5 only supports indexed searches by the start of the term - it cannot
search for Chinese/Japanese words in the middle of the sentence.</p>
<p>This is where <a href="https://github.com/signalapp/Signal-FTS5-Extension">Signal's FTS5 Extension</a> comes to the rescue.
It is a <a href="https://www.rust-lang.org/">Rust</a> crate that could be built as either static or shared
library. When plugged into SQLite this library provides an alternative
tokenizer conspicuously named <code>signal_tokenizer</code>. Creating a table with this
tokenizer is fairly straightforward and one could easily verify that the CJK
search works without issues now:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token comment">-- With extension loaded</span><br><span class="token comment">-- (e.g. after ".load signal-fts5-extension.dylib")</span><br><br><span class="token keyword">CREATE</span> VIRTUAL <span class="token keyword">TABLE</span> search<br>    <span class="token keyword">USING</span> fts5<span class="token punctuation">(</span>content<span class="token punctuation">,</span> tokenize<span class="token operator">=</span><span class="token string">'signal_tokenizer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> search<span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><br>    <span class="token punctuation">(</span><span class="token string">'你好世界'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">SELECT</span> content <span class="token keyword">FROM</span> search<br>    <span class="token keyword">WHERE</span> content <span class="token keyword">MATCH</span> <span class="token string">'世界*'</span><span class="token punctuation">;</span><br><span class="token comment">-- Output: '你好世界'</span></code></pre>
<p><em>Note that default <code>sqlite3</code> shell
doesn't support extensions so you'd have to build your own or use Signal's
<a href="https://github.com/signalapp/better-sqlite3">fork of better-sqlite3</a> which
automatically loads <code>signal_tokenizer</code>.</em></p>
<h2 id="fts5-internal-structure" tabindex="-1">FTS5 Internal Structure <a class="header-anchor" href="#fts5-internal-structure">#</a></h2>
<p>With this context in mind, we are ready to take a look at the internal
structure of FTS5! Let's define the common terminology:</p>
<ul>
<li><strong>document</strong> - a <code>rowid</code> primary key along with one or more indexed text
columns (for simplicity we will assume one)</li>
<li><strong>term</strong> - a &quot;word&quot; in an indexed column. Tokenizer is responsible for
segmenting the text with multiple sentences into <code>term</code>s</li>
<li><strong>segment</strong> - a collection of pages/leaves</li>
<li><strong>page</strong> (<strong>leaf</strong>) - a sorted list of tokens and their positions in the
documents.</li>
</ul>
<h3 id="naive-idea" tabindex="-1">Naive Idea <a class="header-anchor" href="#naive-idea">#</a></h3>
<p>Naively, given a document we could imagine compiling a list of terms and their
positions sorted lexicographically by the term:</p>
<pre class="language-txt" tabindex="0"><code class="language-txt">"hello"  -> rowid1 + position of "hello" in the document<br>"hooray" -> rowid2 + ...<br>"howdy"  -> rowid3 + ...</code></pre>
<p>A binary search could be then performed over the document to find the first
term (and the following terms) with a given prefix.
<a href="https://en.wikipedia.org/wiki/Big_O_notation">The cost</a> of lookups would be:
<code>O(log N)</code>, but the insertions are going to be painful (<code>O(N)</code>) since most
new entries would have to be put into the middle of the list and thus we'd have
to move all older entries forward to make space for them.</p>
<h3 id="b-tree" tabindex="-1">B-Tree <a class="header-anchor" href="#b-tree">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/B-tree">B-Trees</a> were invented to compensate for
that. There is a lot to be said about them, but the only relevant part for our
discussion is that B-Trees work by splitting the data into pages, each
page individually sorted, and then organizing the pages into a binary tree-like
structure. Inserting new data then mostly touches a single page and some nodes
in the tree along the way to that page. This amortizes the insertion performance
to <code>O(log N)</code> (from <code>O(N)</code> of the &quot;big sorted list&quot; described above).</p>
<p>Because of these performance characteristics, B-Trees are ubiquitous in the
&quot;database world&quot;. Some version of them (e.g., <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ Tree</a>) is used in
practically every popular database.</p>
<h3 id="outline-of-fts5-approach" tabindex="-1">Outline of FTS5 Approach <a class="header-anchor" href="#outline-of-fts5-approach">#</a></h3>
<p>While the above approach would work for full-text search, it doesn't take in
account the specifics of it. Namely, users usually insert large documents that
consist of many terms, and commonly perform lookup by just a few terms.</p>
<p>I believe this was the motivation for the approach that SQLite took with FTS5.
Instead of plain <a href="https://en.wikipedia.org/wiki/B-tree">B-Trees</a> FTS5 uses a structure that has even better
amortization for insertions at a price of a slight overhead during the lookup.</p>
<p>Roughly the data is split into three tables:</p>
<ul>
<li><code>%_data</code> - holds the header of the structure with levels description, and
the contents of segments (sorted lists) of doclists (term + document rowid +
positions of the term in the document). This table is indexed by <a href="https://www.sqlite.org/rowidtable.html">rowid</a>
(i.e. an integer primary key)</li>
<li><code>%_idx</code> - holds the triples (segment id, term, page number) to index within
each segment. This table is indexed by <code>segment id</code> and <code>term</code>, so that we
could find the page number in a segment efficiently</li>
<li><code>%_content</code> - holds the full contents of the stored documents (note that this
table is omitted when FTS5 is configured to use
<a href="https://www.sqlite.org/fts5.html#external_content_and_contentless_tables">external content</a>).</li>
</ul>
<p><em>(Note: <code>&quot;%&quot;</code> is the virtual table name, e.g. <code>search</code> in our examples)</em></p>
<p>With the overview above, let's build the structure bottom up. When a new
document is inserted into the table:</p>
<ol>
<li>It is tokenized into multiple terms and their positions within the document</li>
<li>A new segment is created for all these terms, and it is essentially what we
called &quot;big sorted list&quot; above. A segment could be one page if it is small
(less than 1000 bytes, see <a href="https://www.sqlite.org/fts5.html#the_pgsz_configuration_option"><code>pgsz</code> config option</a>), or it could be
split into multiple sorted pages (leaves)</li>
<li>If the segment is split into multiple pages - we take a prefix of the first
term from each sorted page and put them into <code>%_idx</code> table. Thus we
indirectly create a <a href="https://en.wikipedia.org/wiki/B-tree">B-Tree</a>! <code>%_idx</code> becomes a tree part of B-Tree
(because it is indexed by a B+-Tree under the hood), and this tree points to
pages in the <code>%_data</code> table. Each page small enough that we could search it
for terms and their documents</li>
<li>Finally, if FTS5 isn't running in the &quot;external content&quot; mode - we insert the
original (non-tokenized) contents of the document into the <code>%_content</code> table.</li>
</ol>
<p>With this structure it is easy to see how FTS5 performs a search over a single
segment, but what if we insert multiple documents into the index over time?</p>
<h3 id="merging-segments" tabindex="-1">Merging segments <a class="header-anchor" href="#merging-segments">#</a></h3>
<p>Each time we insert a new document - we create a new segment with its terms
(just as described above). If the number of segments is small, when looking up a
term in the index we'd just iterate through all of them starting with the newest
segments! This is the insertion amortization technique in the nutshell. We just
create a brand new B-Tree (through a combination of rows in <code>%_idx</code> and
<code>%_data</code>) and get a forest of them.</p>
<p>When the number of segments becomes too large, however, B-Tree forest can
quickly become impractical. Thus every now and then (every 64 insertions in
SQLite) SQLite has to perform &quot;merges&quot; of some of these segments and create
larger (but more efficient) B-Trees. There are various ways to configure how
these merges work, and how much data is merged. I previously
<a href="https://gist.github.com/indutny/ae44fd93dde2736205609d19a21b87cc">covered the mechanics of the merges</a>
so we won't concentrate on them here.</p>
<p>Every time a merge is performed - we have to combine together two segments and
move all their data into a new one. This sounds like it could be... slow, right?
In fact it very well would be if not for a trick that FTS5 employs! Instead of
just merging everything together any time we get too many segments - we assign
each segment a level. They all start with level 0 and the merges only affect
segments on the <strong>same level</strong>. When they are finally merged - the resulting
segment is one level above the source segments. Since we merge every 64
insertions, with each new level segments become ~64 times larger.
This way we reduce the merge frequency for older and larger segments on
a higher level, and perform most merges on the lower levels when they become
overcrowded.</p>
<h3 id="inspecting-the-structure" tabindex="-1">Inspecting the Structure <a class="header-anchor" href="#inspecting-the-structure">#</a></h3>
<p>Let's see how this works in practice. There is a &quot;secret&quot; test-only function in
FTS5 named <code>fts5_decode</code> that is unfortunately only available when <code>SQLITE_TEST</code>
was defined at the build time. <code>sqlite3</code> shell isn't supposed to be built with
this define, but with a <a href="https://gist.github.com/indutny/01cccb511059a0e2d657036e2fc9cb67">small patch</a> we could get it running:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">CREATE</span> VIRTUAL <span class="token keyword">TABLE</span> search<br>    <span class="token keyword">USING</span> fts5<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">-- Limit max page size for instructiveness</span><br><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> search<span class="token punctuation">(</span>search<span class="token punctuation">,</span> rank<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><br>    <span class="token punctuation">(</span><span class="token string">'pgsz'</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> search<span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><br>    <span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">SELECT</span> rowid<span class="token punctuation">,</span> fts5_decode<span class="token punctuation">(</span>rowid<span class="token punctuation">,</span> block<span class="token punctuation">)</span><br>    <span class="token keyword">FROM</span> search_data<span class="token punctuation">;</span><br><span class="token comment">-- Output (with manual indenting):</span><br><span class="token comment">--</span><br><span class="token comment">-- 1|{averages} 1 2</span><br><span class="token comment">-- 10|{structure} {lvl=0 nMerge=0 nSeg=1 {id=1 leaves=1..1}}</span><br><span class="token comment">-- 137438953473|{segid=1 h=0 pgno=1}</span><br><span class="token comment">--     term=0hello id=1 nPos=1 2</span><br><span class="token comment">--     term=0world id=1 nPos=1 3</span></code></pre>
<p>If we ignore the <code>{averages}</code> (it is used for ranking), we see that in the
<code>{structure}</code> we have one level (<code>lvl=0</code>) with one segment
(<code>nSeg=1 {id=1 leaves=1..1}</code>) that consists of a single page (<code>1..1</code>).</p>
<p>Row <code>137438953473</code> (0x2000000001, see
<a href="https://www.sqlite.org/fts5.html#data_structure">the official documentation on the value</a>)
has the actual segment page which contains a sorted list of terms and
their positions within the document (as promised!). They all start with &quot;0&quot;,
because FTS5 supports optional
<a href="https://www.sqlite.org/fts5.html#prefix_indexes">prefix indexes</a> which require
this encoding.</p>
<p>We can insert more data into the index:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> search<span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><br>    <span class="token punctuation">(</span><span class="token string">'how was your day'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">SELECT</span> rowid<span class="token punctuation">,</span> fts5_decode<span class="token punctuation">(</span>rowid<span class="token punctuation">,</span> block<span class="token punctuation">)</span><br>    <span class="token keyword">FROM</span> search_data<span class="token punctuation">;</span><br><span class="token comment">-- Output (from now on without {averages}, and</span><br><span class="token comment">--   with hex segment ids):</span><br><span class="token comment">--</span><br><span class="token comment">-- 10|{structure} {lvl=0 nMerge=0 nSeg=2</span><br><span class="token comment">--   {id=1 leaves=1..1}</span><br><span class="token comment">--   {id=2 leaves=1..2}}</span><br><span class="token comment">-- 0x2000000001|{segid=1 h=0 pgno=1}</span><br><span class="token comment">--   term=0hello id=1 nPos=1 2</span><br><span class="token comment">--   term=0world id=1 nPos=1 3</span><br><span class="token comment">-- 0x4000000001|{segid=2 h=0 pgno=1}</span><br><span class="token comment">--   term=0day id=2 nPos=1 5</span><br><span class="token comment">--   term=0how id=2 nPos=1 2</span><br><span class="token comment">--   term=0was id=2 nPos=1 3</span><br><span class="token comment">-- 0x4000000002|{segid=2 h=0 pgno=2}</span><br><span class="token comment">--   term=0your id=2 nPos=1 4</span></code></pre>
<p>It is easy to see that the segment 1 wasn't changed, and we added one more
level zero segment (<code>{id=2 leaves=1..2}</code>) with two pages (<code>1..2</code>,
<code>0x4000000001</code> and <code>0x4000000002</code>) because the terms didn't all fit into a
single page. Each page is again a sorted list, and they are now inserted into
the <code>%_idx</code> table:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> search_idx<span class="token punctuation">;</span><br><br><span class="token comment">-- Output (with column names):</span><br><span class="token comment">-- segment id | term | page number</span><br><span class="token comment">-- 1          |      | 2</span><br><span class="token comment">-- 2          |      | 2</span><br><span class="token comment">-- 2          | 0y   | 4</span></code></pre>
<p>One can see that for the newly inserted segment 2 we have two entries (one per
each page), and that they correctly start with <code>&quot;0y&quot;</code> term prefix which lets us
quickly find the page if we are searching by <code>&quot;y*&quot;</code>.</p>
<p>To finish this, let's simulate merging of the segments. We could insert 62 more
entries to trigger it, but a similar result could be achieved by running
<a href="https://www.sqlite.org/fts5.html#the_optimize_command"><code>optimize</code></a>:</p>
<pre class="language-sql" tabindex="0"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> search<span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><br>    <span class="token punctuation">(</span><span class="token string">'optimize'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">SELECT</span> rowid<span class="token punctuation">,</span> fts5_decode<span class="token punctuation">(</span>rowid<span class="token punctuation">,</span> block<span class="token punctuation">)</span><br>    <span class="token keyword">FROM</span> search_data<span class="token punctuation">;</span><br><span class="token comment">-- Output:</span><br><span class="token comment">-- 10|{structure}</span><br><span class="token comment">--   {lvl=0 nMerge=0 nSeg=0}</span><br><span class="token comment">--   {lvl=1 nMerge=0 nSeg=1 {id=3 leaves=1..3}}</span><br><span class="token comment">-- 0x6000000001|{segid=3 h=0 pgno=1}</span><br><span class="token comment">--   term=0day id=2 nPos=1 5</span><br><span class="token comment">--   term=0hello id=1 nPos=1 2</span><br><span class="token comment">--   term=0how id=2 nPos=1 2</span><br><span class="token comment">-- 0x6000000002|{segid=3 h=0 pgno=2}</span><br><span class="token comment">--    term=0was id=2 nPos=1 3</span><br><span class="token comment">--    term=0world id=1 nPos=1 3</span><br><span class="token comment">--    term=0your id=2 nPos=1</span><br><span class="token comment">-- 0x6000000003|{segid=3 h=0 pgno=3}</span><br><span class="token comment">--    4</span><br><br><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> search_idx<span class="token punctuation">;</span><br><span class="token comment">-- Output:</span><br><span class="token comment">-- segment id | term | page number</span><br><span class="token comment">-- 3          |      | 2</span><br><span class="token comment">-- 3          | 0w   | 4</span></code></pre>
<p>As promised, the segments 1 and 2 got merged into a segment 3 on the newly
created level 1. The result has three pages, where the last one has the left
over term position that didn't fit into page 2.</p>
<p>If we insert more data into the table - it will be put again on the level 0 so
the next automatic merge would only work with the segments of that level.</p>
<h2 id="closing-note" tabindex="-1">Closing Note <a class="header-anchor" href="#closing-note">#</a></h2>
<p>I don't know about you, but for me this was quite a wild ride! B-Trees,
tokenizers, merges... There's certainly a lot going on under the hood of
<a href="https://www.sqlite.org/mostdeployed.html">one of the most popular databases</a> in
the world. As it often is in engineering, by reusing and combining simple blocks
we can create a very complex structure that might be hard to understand when
approaching head on. In this article I attempted to deconstruct FTS5 down to its
roots (or at least a few levels lower), but there is still much more that could
be said (like compact encoding of terms and positions in the pages).</p>
<p>If you have any requests or ideas - feel free to &quot;toot&quot; at me on
<a href="https://fosstodon.org/@indutny">Mastodon</a>. Thanks for spending your time
reading this!</p>

<ul class="links-nextprev"><li>Previous: <a href="/12.hashwick-v8-vulnerability/">HashWick V8 Vulnerability</a></li>
</ul>

		</main>

		<footer>
      Copyright Fedor Indutny 2023;
      <a href="https://github.com/indutny/blog" target="_blank" rel="noreferrer">Released</a>
      under
      <a href="https://opensource.org/licenses/mit-license.php" target="_blank" rel="noreferrer">
        MIT license
      </a>.
    </footer>

		<!-- Current page: /13.sqlite-fts5-structure/ -->
	</body>
</html>
